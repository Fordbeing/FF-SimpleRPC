Simple-RPC-Easy 是一个用于给大家了解最简单的 RPC 原理的基础项目，只包含了最基础的远程调用功能，想要进一步了解RPC原理请切入main分支

小白请从这个项目开始了解原理，代码包含了核心注解，方便大家学习参考
# 🔌 Simple-RPC-Easy

> 🧠 一个手写轻量级 RPC 框架项目，帮助你从零掌握 RPC 原理  
> ✨ 目标：让远程调用像本地方法调用一样自然！

---

## 📚 项目介绍

**Simple-RPC-Easy** 是一个简洁清晰的手写 RPC 框架，用最基础的技术实现最核心的远程调用原理。

该项目主要用于教学/自研用途，通过模拟本地调用过程，帮助开发者理解 RPC 的底层机制。

---

## 🚀 项目特点

- ✅ 使用 **JDK 动态代理** 实现服务调用伪装
- ✅ 使用 **原生 HTTP 服务** 作为通信协议
- ✅ 使用 **JDK 自带序列化机制**
- ✅ 使用 **本地 Map 模拟注册中心**
- ✅ 结构清晰，易于扩展（可对接 Netty、Protobuf、Zookeeper）

---

## 📦 项目结构

```bash
simple-rpc-easy/
│
├── rpc-core/                # RPC 核心模块
│   ├── proxy/               # 动态代理生成
│   ├── transport/           # 网络通信（客户端/服务端）
│   ├── registry/            # 注册中心（本地 Map 实现）
│   ├── serialization/       # 序列化/反序列化
│   └── model/               # 请求/响应对象结构
│
├── rpc-provider/            # 服务提供方（提供 UserService 实现）
│   └── ...                  # 启动类 + 接口实现
│
├── rpc-consumer/            # 服务消费方（调用远程方法）
│   └── ...                  # 示例代码
│
└── README.md                # 项目说明文档

```

---

## 🧠 核心流程图

Consumer 发起调用
        ↓
调用代理对象方法（如 userService.getUser(...)）
        ↓
动态代理拦截 → 构造 RpcRequest → 序列化
        ↓
通过 HTTP 发送至 Provider
        ↓
Provider 接收请求 → 反序列化 → 反射调用目标方法
        ↓
执行方法 → 构造 RpcResponse → 序列化返回
        ↓
Consumer 接收响应 → 反序列化 → 返回结果


---

## 🛠️ 技术栈

组件	技术栈
通信层	原生 HTTP
注册中心	本地 Map 实现
序列化	JDK 序列化
动态代理	JDK Proxy
方法调用	Java 反射


---

## 🔧 待优化 / 可扩展方向
	•	替换为 Netty 实现高性能通信
	•	引入 Protobuf 序列化提高性能与跨语言能力
	•	使用 Zookeeper / Nacos 实现注册中心
	•	加入负载均衡、重试机制、熔断限流等特性
	•	实现异步调用、超时控制、链路追踪等

---

## 📄 License

本项目仅用于学习和研究目的，欢迎自由 Fork & 学习！

---

## 🙋‍♂️ 作者
	•	👤 FF
	•	📝 喜欢钻研底层、构建工具、分享技术
	•	📬 有问题欢迎交流！
