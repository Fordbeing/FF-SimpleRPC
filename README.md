# ⚡ Simple-RPC-Easy (High Performance Edition)

不仅仅是能用的 RPC，更是能调、能扩、能折腾的 RPC  
一个从零开始构建的可扩展高性能 RPC 框架

这是我从零写的 RPC 框架。  
一开始只是想验证想法，结果越做越多：  
多序列化、多网络实现、可插拔负载均衡、可选注册中心、SPI 扩展机制……  
到现在已经是一个"能跑上生产"的雏形。

为了避免**"写死在代码里，三个月后自己都嫌弃"**的情况，我在设计时刻意保留了大量可扩展接口，让它有足够的生命力和可玩空间。

## 🚀 核心特性

### 1. 全局配置（Global Configuration）

为什么要做？  
最初的 Demo 中，所有参数都是硬编码的，比如：

```java
new ZookeeperRegistry("127.0.0.1:2181");
```

两周后想换成 Etcd，要改的地方比想象中多。于是我做了统一配置中心，让一行改动全局生效。

设计原则：
- 配置集中化：统一入口，方便维护
- 优先级：环境变量 > 配置文件 > 框架默认值（方便本地调试 + 生产覆盖）
- 支持热更新：动态调整负载均衡、序列化方式等，无需重启

示例配置：

```yaml
rpc:
  serializer: kryo
  transport:
    type: netty
    requestTimeoutMs: 500
  loadBalance:
    strategy: consistent_hash
  registry:
    type: zookeeper
    address: 127.0.0.1:2181
```

💡 个人想法  
全局配置不只是"把硬编码挪到 yml"，它应该有优先级、有默认值、有热加载。这样调试、灰度、线上应急都能快速调整。

---

### 2. SPI 扩展机制

为什么要做？  
我不想让框架变成"JDK 序列化 + Zookeeper + Netty"的单一组合，而是希望用户能混搭，比如 Protobuf + Nacos + gRPC。

支持自定义的模块：
- 序列化器（Serializer）
- 注册中心（Registry）
- 网络服务器（Transport Server）
- 负载均衡器（LoadBalancer）

示例：自定义序列化器

```java
@RpcSPI("protobuf")
public class ProtobufSerializer implements Serializer {
    @Override
    public <T> byte[] serialize(T obj) {
        // Protobuf 序列化逻辑
    }
    @Override
    public <T> T deserialize(byte[] bytes, Class<T> clazz) {
        // Protobuf 反序列化逻辑
    }
}
```

💡 个人想法  
SPI 用"契约 + 动态加载"替代 if/else 分支，不依赖我更新，别人也能加功能，让框架更有生命力。

---

### 3. 多序列化方式

内置支持：
- JDK：兼容性好，调试方便
- JSON：可读性好，便于日志排查
- Hessian：跨语言友好
- Kryo：性能高，体积小

可扩展：通过 SPI 接入 Protobuf、Avro、FST 等。

💡 个人想法  
不同场景取舍不同：调试时 JSON 爽，追求极致性能时 Kryo 更合适。

---

### 4. 自定义二进制协议

Header（固定长度）：

| 字段 | 长度 | 描述 |
|------|------|------|
| 魔数(Magic) | 2B | 协议识别 |
| 序号(SeqId) | 8B | 请求唯一 ID |
| 版本号(Version) | 1B | 协议版本 |
| 响应类型(Type) | 1B | 请求 / 响应 / 异常 / 心跳 |
| 序列化方式(Ser) | 1B | JDK / JSON / Hessian / Kryo |
| 状态码(Code) | 1B | 成功 / 失败 / 异常 |
| 消息体长度(BodyLen) | 4B | Body 字节长度 |

Body：序列化后的对象数据。

💡 个人想法  
相比直接用 HTTP，自定义协议更轻量、可控、解析成本低。魔数和版本号放前面方便快速判断兼容性。

---

### 5. 粘包 / 拆包解决方案

支持：
1. 消息体长度 + 消息体
2. Vert.x RecordParser 分隔符方式
3. 消息体长度 + 固定长度方式

💡 个人想法  
分隔符方案遇到二进制数据包含分隔符时会出问题，所以我更偏向长度字段方案。

---

### 6. 多网络服务器实现
- Vert.x HTTP（响应式）
- 原生 HTTP（易调试）
- Netty（高性能）

💡 个人想法  
Vert.x 用来体验事件驱动和回压机制；Netty 则冲击性能极限；原生 HTTP 方便新人理解。

---

### 7. 负载均衡算法
- 随机（Random）
- 轮询（Round Robin）
- 一致性哈希（Consistent Hash）

💡 个人想法  
一致性哈希在缓存场景特别香，我调了虚拟节点数量，让节点变动更平滑。

---

### 8. 注册中心
- Etcd（强一致性，Raft 协议）
- Zookeeper（成熟稳定）
- 可扩展接入 Nacos、Consul

💡 个人想法  
我偏爱 Etcd 的强一致性和 API 直观性，但 Zookeeper 在国内更常用，所以两个都做了。

---

## 📖 总结

这个项目对我来说，是一次完整的**"从零到可生产"工程实践**。  
它让我更理解：
- 为什么要搞 SPI、全局配置、协议头、拆包方案
- 哪些设计是为了性能
- 哪些是为了可维护性和扩展性

最重要的一点  
它的设计就是为了"可玩"，能无痛接入 QUIC、Protobuf、Nacos，而不改核心代码，这就是我的初衷。


以下是针对 Simple-RPC-Easy 框架的后续待实现功能与扩展方向，延续“可扩展、高性能、贴近生产”的设计理念，补充生产级所需的关键能力：


## 📌 后续待实现功能与扩展方向

### 1. 服务治理增强
- **熔断与限流**  
  集成熔断器模式（如基于 Resilience4j 或 Sentinel），当服务节点异常比例超过阈值时自动熔断，避免级联失败；支持基于令牌桶/漏桶的限流策略，限制单服务/单接口的 QPS，保护服务稳定性。  
  *价值*：提升框架在高负载或异常场景下的容错能力，防止服务被流量冲垮。

- **服务降级**  
  支持接口级别的降级策略，当服务压力过大时，自动切换到预设的降级逻辑（如返回缓存数据、默认值），保证核心流程可用。  
  *价值*：在资源紧张时优先保障核心业务，牺牲非核心功能换取系统整体稳定性。


### 2. 监控集成

- **指标监控**  
  暴露标准化监控指标（如调用成功率、平均响应时间、并发数、序列化/反序列化耗时），支持 Prometheus 采集与 Grafana 可视化；添加节点级监控（CPU/内存使用率、网络IO），为负载均衡提供数据支撑。  
  *价值*：量化框架运行状态，便于运维监控和性能调优。


### 3. 网络传输优化
- **QUIC 协议支持**  
  新增基于 QUIC 协议的传输实现（基于 Netty QUIC 或 Jetty QUIC），利用其“0-RTT 握手”“连接迁移”特性，降低弱网环境（如移动端、跨地域调用）的延迟，提升传输可靠性。  
  *价值*：补充 UDP 级别的低延迟传输能力，适应更多场景（如实时通信、边缘计算）。

- **TCP 性能调优**  
  优化 Netty 底层参数：启用 `SO_REUSEPORT` 提升多核 CPU 利用率，调整 TCP 拥塞控制算法（如 BBR），支持 TCP 快速打开（TFO），进一步降低传输延迟。  


### 4. 安全增强
- **传输加密与鉴权**  
  支持 TLS/SSL 加密传输（基于 OpenSSL 或 JDK 原生实现），确保数据在网络传输中不被窃听；添加接口级鉴权机制（如 AK/SK 签名、JWT 令牌），验证调用方身份，防止未授权访问。  
  *价值*：满足金融、政务等场景的安全合规要求，保护敏感接口调用。


### 5. 高级负载均衡策略
- **动态感知负载均衡**  
  结合服务节点的实时监控数据（CPU 使用率、内存占用、响应时间），实现“最小负载优先”“最小响应时间”等动态策略，而非静态权重；支持自定义负载均衡器 SPI，允许用户基于业务场景（如地理位置、机房）定制路由逻辑。  
  *价值*：让流量更智能地分配到“健康且空闲”的节点，提升整体资源利用率。


### 6. 响应式与异步能力增强
- **全链路异步化**  
  扩展接口支持 `CompletableFuture` 异步调用，结合 Netty 的异步 IO 实现“非阻塞到底”；引入响应式编程接口（基于 Reactive Streams 规范，如 RxJava 或 Project Reactor），支持背压（Backpressure）机制，适配高并发流处理场景。  
  *价值*：提升高并发场景下的吞吐量，避免线程阻塞导致的资源浪费。


### 7. 注册中心与配置中心深度集成
- **Nacos 注册中心支持**  
  补充 Nacos 作为注册中心实现，利用其“服务发现 + 动态配置”一体化能力，简化部署架构；支持 Nacos 的权重配置、元数据管理，与负载均衡策略联动。  
  *价值*：适配国内主流微服务生态，降低用户迁移成本。

- **配置中心联动**  
  与外部配置中心（如 Apollo、Nacos Config）深度集成，支持框架参数（如序列化方式、超时时间）和业务配置的动态推送，无需重启服务即可生效，统一配置管理入口。  


### 8. 服务健康检查与自动运维
- **主动健康探测**  
  实现服务节点的主动健康检查（如 TCP 心跳、HTTP 健康接口、自定义脚本探测），结合注册中心自动下线不健康节点；支持“灰度上线”能力，新节点启动后先接收少量流量，确认健康后逐步放大流量。  
  *价值*：减少人工干预，提升服务可用性，降低发布风险。


## 💡 设计思路
所有扩展均遵循“SPI 插件化”原则，不侵入核心逻辑：  
- 新增功能通过 SPI 接口扩展（如 `CircuitBreaker SPI`、`RateLimiter SPI`），用户可按需集成；  
- 保持“配置驱动”，所有新功能的开关/参数均可通过全局配置动态调整（如熔断阈值、加密开关）；  
- 优先满足生产级刚需（稳定性、可观测性、安全性），再扩展场景化能力（如 QUIC、响应式）。

加油吧，少年，冲向大厂，拥抱大厂版！
